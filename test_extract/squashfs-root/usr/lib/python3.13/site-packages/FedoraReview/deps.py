# -*- coding: utf-8 -*-

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

""" Interface to package dependencies. """

import shlex
import subprocess

try:
    from subprocess import check_output  # pylint: disable=E0611
except ImportError:
    from FedoraReview.el_compat import check_output

from .settings import Settings


def init():
    """Setup module for subsequent calls."""
    # pk.refresh_cache would be better, but requires privileges.
    # Might be solvable, see
    # https://bugs.launchpad.net/ubuntu/+source/packagekit/+bug/1008106
    try:
        check_output(
            [
                "mock",
                "-r",
                Settings.mock_config,
                *shlex.split(Settings.mock_options),
                "-qn",
                "install",
                "dnf",
                # This will install the older DNF version (lesser than DNF5)
                # which provides /usr/bin/dnf-3
                # We can use this for some use-cases that doesn't work with
                # DNF5 yet. For example `dnf5 repoquery` misses some parameters
                # https://github.com/rpm-software-management/dnf5/issues/696
                "python3-dnf",
            ]
        )
    except subprocess.CalledProcessError:
        Settings.get_logger().warning("Cannot install dnf, trouble ahead")
    try:
        check_output(
            [
                "mock",
                "-r",
                Settings.mock_config,
                *shlex.split(Settings.mock_options),
                "-qn",
                "--enable-network",
                "--pm-cmd",
                "--",
                # We want to run `dnf makecache` here but for some reason, it
                # doesn't relly make the consequent `repoquery -C` commands
                # work. Let's simply repoquery without the cache-only to
                # properly create any needed cache for the consequent calls.
                "repoquery", "-l", "hello",
            ]
        )
    except subprocess.CalledProcessError:
        Settings.get_logger().warning("Cannot run dnf makecache, trouble ahead")


def list_deps(pkgs):
    """Return list of all dependencies for named pkgs (scalar or list)."""

    if not isinstance(pkgs, list):
        pkgs = [pkgs]
    if not pkgs:
        return []

    cmd = [
        "mock",
        "-r",
        Settings.mock_config,
        *shlex.split(Settings.mock_options),
        "-qn",
        "--enable-network",
        "--shell",
        "--",
        "dnf", "repoquery", "-q", "-C", "--requires", "--providers-of=requires",
    ]
    cmd += [f"'{x}'" for x in set(pkgs)]

    Settings.get_logger().debug("Running: %s", " ".join(cmd))
    try:
        dnf = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run %s", " ".join(cmd))
        return []
    deps = []
    while True:
        try:
            line = next(dnf.stdout).strip()
        except StopIteration:
            return list(set(deps))
        name = line.rsplit(".", 2)[0]
        deps.append(name.rsplit("-", 2)[0])


def list_provides(pkgs):
    """Return list of all provides for named pkgs (scalar or list)."""

    if not isinstance(pkgs, list):
        pkgs = [pkgs]
    if not pkgs:
        return []

    cmd = [
        "mock",
        "-r",
        Settings.mock_config,
        *shlex.split(Settings.mock_options),
        "-qn",
        "--enable-network",
        "--shell",
        "--",
        "dnf", "repoquery", "-q", "-C", "--provides",
    ]
    cmd += [f"'{x}'" for x in set(pkgs)]

    Settings.get_logger().debug("Running: %s", " ".join(cmd))
    try:
        dnf = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run %s", " ".join(cmd))
        return []
    provides = []
    while True:
        try:
            line = next(dnf.stdout).strip()
        except StopIteration:
            return list(set(provides))
        provides.append(line)


def resolve(reqs):
    """Return the packages providing the reqs symbols."""

    if not isinstance(reqs, list):
        reqs = [reqs]
    if not reqs:
        return []
    reqs = list(set(reqs))

    # Apply resolution to each req individually (old yum repoquery allowed you
    # to specify multiple packages at once, but dnf repoquery only allows one
    # at a time).  Then concatenate all those lists of providers together
    # and return.
    return [elem for list_ in map(resolve_one, reqs) for elem in list_]


def resolve_one(req):
    """Return the packages providing the req symbol."""
    cmd = [
        "mock",
        "-r",
        Settings.mock_config,
        *shlex.split(Settings.mock_options),
        "-qn",
        "--enable-network",
        "--shell",
        "--",
        "dnf", "repoquery", "-q", "-C", "--whatprovides", f"'{req}'",
    ]
    Settings.get_logger().debug("Running: %s", " ".join(cmd))

    try:
        dnf = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run %s", " ".join(cmd))
        return []

    pkgs = []
    while True:
        try:
            line = next(dnf.stdout).strip()
        except StopIteration:
            return list(set(pkgs))

        # Skip a line from dnf repoquery that should've gone to stderr
        if " metadata " in line:
            continue

        pkg = line.rsplit(".", 2)[0]
        pkgs.append(pkg.rsplit("-", 2)[0])


def list_dirs(pkg_filename):
    """Return list of directories in local pkg."""

    cmd = ["rpm", "-ql", "--dump", "-p", pkg_filename]
    try:
        rpm = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run %s", " ".join(cmd))
        return []
    dirs = []
    while True:
        try:
            line = next(rpm.stdout).strip()
        except StopIteration:
            return dirs
        try:
            path, mode = line.rsplit(None, 10)[0:5:4]
        except ValueError:
            # E. g., when given '(contains no files)'
            continue
        mode = int(mode, 8)
        if mode & 0o40000:
            dirs.append(path)


def list_owners(paths):
    """Return list of packages owning paths (single path or list)."""
    if not paths:
        return []
    if not isinstance(paths, list):
        paths = [paths]

    owners = []
    paths_to_exam = list(paths)
    for path in paths:
        p = subprocess.Popen(
            [
                "mock",
                "-r",
                Settings.mock_config,
                *shlex.split(Settings.mock_options),
                "-qn",
                "--enable-network",
                "shell",
                "--",
                "rpm --qf %{NAME}\n -qf " + path,
            ],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            universal_newlines=True,
        )
        path_owners = p.communicate()[0].split()
        if p.returncode != 0:
            continue
        path_owners = [p.strip() for p in path_owners]
        if path_owners and path_owners[0]:
            path_owners = [p for p in path_owners if not p.startswith("error:")]
        if not path_owners or not path_owners[0]:
            continue
        paths_to_exam.remove(path)
        owners.extend(path_owners)
    for path in paths_to_exam:
        cmd = [
            "mock",
            "-r",
            Settings.mock_config,
            *shlex.split(Settings.mock_options),
            "-qn",
            "--enable-network",
            "--shell",
            "--",
            "dnf", "repoquery", "-C", "--quiet", "--file", path,
        ]
        Settings.get_logger().debug("Running: %s", " ".join(cmd))
        try:
            lines = check_output(cmd, universal_newlines=True).split()
            lines = [line.strip() for line in lines]
            if not lines or not lines[0]:
                continue
            lines = [line.rsplit(".", 2)[0] for line in lines]
            lines = [line.rsplit("-", 2)[0] for line in lines]
            owners.extend(list(set(lines)))
        except subprocess.CalledProcessError:
            Settings.get_logger().error("Cannot run %s", " ".join(cmd))
            return owners
    return owners


def list_paths(pkgs):
    """Return list of all files in pkgs (single name or list)."""
    if not pkgs:
        return []
    if not isinstance(pkgs, list):
        pkgs = [pkgs]

    cmd = [
        "mock",
        "-r",
        Settings.mock_config,
        *shlex.split(Settings.mock_options),
        "-qn",
        "--enable-network",
        "--shell",
        "--",
        "dnf", "repoquery", "-C", "-l",
    ]
    cmd += [f"'{x}'" for x in set(pkgs)]

    Settings.get_logger().debug("Running: %s", " ".join(cmd))
    try:
        paths = check_output(cmd, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run dnf repoquery")
        return []
    return paths.split()


def listpaths(pkg_filename):
    """Return lists of files and dirs in local pkg."""

    cmd = ["rpm", "-ql", "--dump", "--nosignature", "-p", pkg_filename]
    Settings.get_logger().debug("Running: %s", " ".join(cmd))
    try:
        rpm = subprocess.Popen(cmd, stdout=subprocess.PIPE, universal_newlines=True)
    except OSError:
        Settings.get_logger().warning("Cannot run %s", " ".join(cmd))
        return []
    files = []
    dirs = []
    while True:
        try:
            line = next(rpm.stdout).strip()
        except StopIteration:
            return dirs, files
        try:
            path, mode = line.rsplit(None, 10)[0:5:4]
        except ValueError:
            # E. g., when given '(contains no files)'
            continue
        mode = int(mode, 8)
        if mode & 0o40000:
            dirs.append(path)
        else:
            files.append(path)


class Deps(object):
    """Models the dependencies."""

    def list_owners(self, path):
        """Return possobly empty list of owners to path."""
        pass

    def get_spec(self, pkg):
        """Return a Spec object for a given dependency pkg."""
        pass


# vim: set expandtab ts=4 sw=4:
