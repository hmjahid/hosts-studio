#    -*- coding: utf-8 -*-

#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.


"""
This program aims to provide a simple way to create review-request on
the Red Hat's bugzilla for Fedora products.

The idea is:
- from a spec and srpm
  - start a koji scratch build
  - if build worked
    - upload to fedorapeople.org
    - create the bugzilla ticket
    - Add the koji build in the bugzilla as a link
  - otherwise:
    - warn user
"""

from __future__ import print_function

import argparse
import getpass
import logging
import os
import stat
import subprocess
import sys
from subprocess import Popen, check_output

import rpm
import six.moves.configparser
from bugzilla.rhbugzilla import RHBugzilla
from six.moves import input
from six.moves.xmlrpc_client import Fault

SETTINGS_FILE = os.path.join(os.environ["HOME"], ".config", "fedora-create-review")

BUG_COMMENT = """Spec URL: %s
SRPM URL: %s

Description:
%s

Fedora Account System Username: %s
"""

# Initial simple logging stuff
logging.basicConfig()
LOG = logging.getLogger("fedora-create-review")
if "--debug" in sys.argv:
    LOG.setLevel(logging.DEBUG)


def read_fas_user():
    """Try to read FAS username"""
    if os.path.exists(os.path.expanduser("~/.fedora.upn")):
        with open(os.path.expanduser("~/.fedora.upn"), "r") as f:
            return f.read().replace("\n", "")

    klist_line = "Default principal: "
    koutput = check_output("klist", universal_newlines=True).split("\n")
    line = [line for line in koutput if line.startswith(klist_line)][0]
    line = line[len(klist_line) :]
    if line.endswith("@FEDORAPROJECT.ORG"):
        return line[: line.index("@")]

    raise Exception("Could not determine FAS username")


def create_conf(configfile):
    """Check if the provided configuration file exists, generate the
    folder if it does not and return True or False according to the
    initial check.

    :arg configfile, name of the configuration file looked for.
    """
    if not os.path.exists(configfile):
        dn = os.path.dirname(configfile)
        if not os.path.exists(dn):
            os.makedirs(dn)
        return True
    return False


def save_config(configfile, parser):
    """Save the configuration into the specified file.

    :arg configfile, name of the file in which to write the configuration
    :arg parser, ConfigParser object containing the configuration to
    write down.
    """
    with open(configfile, "w") as conf:
        parser.write(conf)


def add_comment_build(output_build, bug):
    """Retrieve the link to the koji build from the output of the
    koji command and add a comment with this link on the review
    request.
    """
    print("Adding comment about the koji build")
    url = None
    for line in output_build.split("\n"):
        if "Task info" in line:
            url = line.split("Task info:")[1]
    comment = "This package built on koji: %s" % url
    bug.addcomment(comment)


def add_comment_copr_build(output_build, bug):
    """Retrieve the link to the Copr build from the output of the
    copr-cli command and add a comment with this link on the review
    request.
    """
    print("Adding comment about the Copr build")
    url = None
    for line in output_build.split("\n"):
        if "https://copr.fedorainfracloud.org" in line:
            url = line.strip()
            break
    comment = "This package built on Copr and review templates: %s" % url
    bug.addcomment(comment)


class FedoraCreateReviewError(Exception):
    """Generic Exception class used for the exception thrown in this
    project."""

    pass


class Settings(object):
    """gitsync Settings"""

    # upload target
    upload_target = "fedorapeople.org:public_html/"
    # bugzilla settings
    bugzilla_api_key = ""
    bugzilla_username = ""

    def __init__(self):
        """Constructor of the Settings object.
        This instantiates the Settings object and loads into the _dict
        attributes the default configuration with each available option.
        """
        self._dict = {
            "bugzilla_api_key": self.bugzilla_api_key,
            "bugzilla_username": self.bugzilla_username,
            "upload_target": self.upload_target,
        }
        self.load_config(SETTINGS_FILE, "fedora-create-review")

    def load_config(self, configfile, sec):
        """Load the configuration in memory.

        :arg configfile, name of the configuration file loaded.
        :arg sec, section of the configuration retrieved.
        """
        parser = six.moves.configparser.ConfigParser()
        configfile = os.path.join(os.environ["HOME"], configfile)
        is_new = create_conf(configfile)
        parser.read(configfile)
        if not parser.has_section(sec):
            parser.add_section(sec)
        self.populate(parser, sec)
        if is_new:
            save_config(configfile, parser)

    def __getitem__(self, key):
        hash_ = self._get_hash(key)
        if not hash_:
            raise KeyError(key)
        return self._dict.get(hash_)

    def populate(self, parser, section):
        """Set option values from a INI file section.

        :arg parser: ConfigParser instance (or subclass)
        :arg section: INI file section to read use.
        """
        if parser.has_section(section):
            opts = set(parser.options(section))
        else:
            opts = set()

        for name in self._dict.keys():
            value = None
            if name in opts:
                value = parser.get(section, name)
                setattr(self, name, value)
                parser.set(section, name, value)
            else:
                parser.set(section, name, self._dict[name])


class ReviewRequest(object):
    """Review Request class, used to be able to keep some information
    within the class.
    """

    USERNAME_PLACEHOLDER = "@username@"
    PKGNAME_PLACEHOLDER = "@pkgname@"

    def __init__(self):
        """Constructor."""
        self.settings = Settings()
        self.info = {}
        self.log = LOG
        self.specfile = ""
        self.spec = ""
        self.srpmfile = ""
        self.username = None
        self.bzclient = None

    def create_review_request(self, rename_request):
        """Create the review request on the bugzilla."""
        print("Creating review")
        review_type = "Review Request"
        if rename_request:
            review_type = "Rename Request"
        data = {
            "product": "Fedora",
            "component": "Package Review",
            "version": "rawhide",
            "short_desc": "{}: {} - {}".format(
                review_type, self.info["name"], self.info["summary"]
            ),
            "comment": BUG_COMMENT
            % (
                self.info["specurl"],
                self.info["srpmurl"],
                self.info["description"],
                self.username,
            ),
            "rep_platform": "Unspecified",
            "bug_severity": "unspecified",
            "op_sys": "Unspecified",
            "bug_file_loc": "",
            "priority": "unspecified",
        }
        if rename_request:
            data["comment"] = (
                data["comment"]
                + "\n\n This is a Rename request for the former package '%s'"
                % rename_request
            )
        self.log.debug("bz.createbug(%s)", data)
        try:
            bug = self.bzclient.createbug(**data)
            bug.refresh()
        except Fault as ex:
            print(ex)
            raise ("Fail to create Bugzilla bug")
        return bug

    def run_command(self, cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE):
        """Run a command and return the output

        :arg cmd, the command to run
        """
        self.log.debug(cmd)
        try:
            proc = Popen(
                cmd,
                stdout=stdout,
                stderr=stderr,
                universal_newlines=True,
            )
            output = proc.communicate()[0]
        except OSError as err:
            print("OSError : %s" % str(err))

        return (output, proc.returncode)

    def refresh_kerberos_ticket(self):
        print("Refreshing Kerberos ticket")
        cmd = ["kinit", "-R"]
        if self.run_command(cmd)[1] == 0:
            return True
        else:
            cmd = ["kinit", "{}@FEDORAPROJECT.ORG".format(self.username)]
            return self.run_command(cmd, stdout=None, stderr=None)[1] == 0

    def do_scratch_build(self, target="rawhide"):
        """Starts a scratch build on koji."""
        if self.refresh_kerberos_ticket():
            print("Starting scratch build")
            cmd = ["koji", "build", "--scratch", target, self.srpmfile]
            return self.run_command(cmd)
        else:
            raise FedoraCreateReviewError("Failed to acquire a valid Kerberos ticket")

    def check_copr_config(self):
        """Check if Copr config file exists."""
        cmd = ["copr-cli", "whoami"]
        output, returncode = self.run_command(cmd)
        prompt = "Log into the Copr web interface and get your API token at the https://copr.fedorainfracloud.org/api/\n"
        prompt += "Save your token to ~/.config/copr"
        if returncode != 0:
            raise FedoraCreateReviewError(
                "Failed to read Copr config: \n" + output + "\n" + prompt
            )
        if "None" in output:
            raise FedoraCreateReviewError("Failed to read Copr config: \n" + prompt)

    def check_copr_proj_exist(self, proj):
        """Check if a Copr project already exists."""
        cmd = ["copr-cli", "list"]
        output, returncode = self.run_command(cmd)
        if returncode != 0:
            raise FedoraCreateReviewError(
                "Failed to get all Copr projects: \n" + output
            )
        return f"Name: {proj}" in output

    def create_copr_project(self, proj, chroots):
        """Create a new Copr project."""
        if len(chroots) == 0:
            raise FedoraCreateReviewError(
                "Failed to create Copr project without chroots, use '--chroot chroot' to specify chroots."
            )
        cmd = ["copr-cli", "create", proj, "--fedora-review"]
        for chroot in chroots:
            cmd.append("--chroot")
            cmd.append(chroot)
        output, returncode = self.run_command(cmd)
        if returncode != 0:
            raise FedoraCreateReviewError(
                f"Failed to create Copr project {proj} with chroots {chroots}: \n"
                + output
            )
        print(f"Create Copr project {proj} with chroots {chroots}")

    def do_copr_build(self, proj, chroots):
        """Starts a build on Copr."""
        self.check_copr_config()
        if not self.check_copr_proj_exist(proj=proj):
            self.create_copr_project(proj=proj, chroots=chroots)
        print("Starting Copr build")
        cmd = ["copr-cli", "build", proj, self.srpmfile]
        return self.run_command(cmd)

    def _expand_placeholders(self, uri):
        """Fill in placeholders."""
        if self.USERNAME_PLACEHOLDER in uri:
            uri = uri.replace(self.USERNAME_PLACEHOLDER, self.username)
        if self.PKGNAME_PLACEHOLDER in uri:
            package_name = self.retrieve_name()
            uri = uri.replace(self.PKGNAME_PLACEHOLDER, package_name)
        if not uri.endswith("/"):
            uri += "/"
        return uri

    def upload_target(self):
        """
        Get the upload target from settings and fill in any placeholders.
        """
        return self._expand_placeholders(self.settings.upload_target)

    def fill_urls(self):
        """
        Fill the spec and src.rpm urls into the info table using the
        info in the settings.
        """
        target = self.settings.upload_target
        # Ensure we're always setting the right fedorapeople URL
        if target.startswith("fedorapeople.org:"):
            target = target.replace("fedorapeople.org:", "@username@.fedorapeople.org:")
        target = self._expand_placeholders(target)

        url = "https://{}".format(target.replace(":public_html", ""))
        self.info["specurl"] = url + os.path.basename(self.specfile)
        self.info["srpmurl"] = url + os.path.basename(self.srpmfile)

    def find_existing_reviews(self):
        """Return information about the review request(s) sumitted
        for a given package.

        This function queries the Fedora/RedHat's bugzilla to find the review
        or reviews submitted for a given package.
        It prints out the bug number, the assignee, the summary and the
        resolution of each bug found.

        :arg packagename the name of the package to search for
        """
        query = {
            #  'bug_status': ['CLOSED'],
            "short_desc": "Request: {} -".format(self.info["name"]),
            "short_desc_type": "allwordssubstr",
            "query_format": "advanced",
            "component": "Package Review",
        }
        bugbz = self.bzclient.query(query)

        if bugbz:
            print("Reviews for a package of the same name have been found:")
        for bug in bugbz:
            print(" ", bug, "-", bug.resolution)
            print("\t", bug.url)

        if bugbz:
            usr_inp = input("Do you want to proceed anyway? [y/N]")
            if not usr_inp.lower().startswith("y"):
                raise FedoraCreateReviewError()

    def login_bz(self):
        """Login into the bugzilla."""
        if self.settings.bugzilla_username:
            username = self.settings.bugzilla_username
        else:
            username = input("Bugzilla username: ")
        self.bzclient.login(user=username, password=getpass.getpass())

    def main(self):
        """The main function."""
        parser = setup_parser()
        args = parser.parse_args()
        if not args.test:
            bzurl = "https://bugzilla.redhat.com"
        else:
            bzurl = "https://partner-bugzilla.redhat.com"
            print("Using test bugzilla at: " + bzurl)

        self.username = args.username
        if not self.username:
            # pylint: disable=bare-except
            try:
                self.username = read_fas_user()
            except Exception:
                self.log.debug("Could not determine FAS username")
                self.username = input("FAS username: ")

        if self.settings.bugzilla_api_key:
            self.bzclient = RHBugzilla(
                url="%s/xmlrpc.cgi" % bzurl, api_key=self.settings.bugzilla_api_key
            )
        else:
            print(
                "Could not find Bugzilla API Key. To create a new API Key: https://bugzilla.redhat.com/userprefs.cgi?tab=apikey"
            )
            self.settings.bugzilla_api_key = input("Bugzilla API Key: ")
            self.bzclient = RHBugzilla(
                url="%s/xmlrpc.cgi" % bzurl, api_key=self.settings.bugzilla_api_key
            )
        self.srpmfile = os.path.expanduser(args.srpmfile)
        self.specfile = os.path.expanduser(args.specfile)
        self.spec = rpm.spec(self.specfile)
        if not args.no_build:
            (output_build, returncode) = self.do_scratch_build(target=args.koji_target)
            if returncode != 0:
                raise FedoraCreateReviewError("Koji build error: \n " + output_build)
        if args.copr_proj is not None:
            (output_copr_build, returncode) = self.do_copr_build(
                proj=args.copr_proj, chroots=args.chroots
            )
            if returncode != 0:
                raise FedoraCreateReviewError(
                    "Copr build error: \n " + output_copr_build
                )
        self.info["summary"] = self.retrieve_summary()
        self.info["description"] = self.retrieve_description()
        self.info["name"] = self.retrieve_name()
        self.find_existing_reviews()
        (output_upload, returncode) = self.upload_files()
        if returncode != 0:
            raise FedoraCreateReviewError("Uploading error(s):\n " + output_upload)
        self.fill_urls()
        bug = self.create_review_request(args.rename_request)
        if not args.no_build:
            add_comment_build(output_build, bug)
        if args.copr_proj is not None:
            add_comment_copr_build(output_copr_build, bug)
        print("Review created at: {}/show_bug.cgi?id={}".format(bzurl, bug.id))
        print(bug)

    def retrieve_description(self):
        """Retrieve the description tag from a spec file."""
        description = self.spec.packages[0].header[1005]
        self.log.debug("Description: %s", description)
        return description

    def retrieve_name(self):
        """Retrieve the name tag from a spec file."""
        name = self.spec.packages[0].header[1000]
        self.log.debug("Name: %s", name)
        return name

    def retrieve_summary(self):
        """Retrieve the summary tag from a spec file."""
        summary = self.spec.packages[0].header[1004]
        self.log.debug("Summary: %s", summary)
        return summary

    def upload_files(self):
        """Upload the spec file and the src.rpm files into
        fedorapeople.org, ensuring readable mode."""
        print("Uploading files into fedorapeople")
        upload_target = self.upload_target()
        self.log.debug("Target: %s", upload_target)
        upload_host, upload_path = upload_target.split(":")
        cmd = [
            "ssh",
            upload_host,
            "mkdir -p {}".format(upload_path),
        ]
        self.run_command(cmd)
        for path in [self.specfile, self.srpmfile]:
            mode = os.stat(path)[0]
            mode |= stat.S_IRUSR | stat.S_IRGRP | stat.S_IROTH
            os.chmod(path, mode)
        cmd = [
            "scp",
            self.specfile,
            self.srpmfile,
            self.username + "@" + upload_target,
        ]
        return self.run_command(cmd)


def setup_parser():
    """
    Set the command line arguments.
    """
    parser = argparse.ArgumentParser(
        prog="fedora-create-review",
        description="Create a new Fedora package review ticket",
        epilog="Please see `man fedora-create-review` for more information, such as how to use the configuration file.\n\n Please file bugs, feature requests, and pull requests at https://pagure.io/FedoraReview/.",
    )
    # General connection options
    parser.add_argument("specfile", help="Path to the spec file")
    parser.add_argument("srpmfile", help="Path to the src.rpm file")
    parser.add_argument("--user", dest="username", help="FAS username")
    parser.add_argument(
        "--rename-request", default=False, help="Former name of the package."
    )
    parser.add_argument(
        "--koji-target",
        default="rawhide",
        help="Target for the koji scratch build (default: rawhide)",
    )
    parser.add_argument(
        "--copr",
        dest="copr_proj",
        help="Copr project to build, can be an existing one or a new one",
    )
    parser.add_argument(
        "--chroot",
        dest="chroots",
        action="append",
        default=[],
        help="Chroots for creating new Copr project",
    )
    parser.add_argument(
        "--test",
        default=False,
        action="store_true",
        help="Run on a test bugzilla instance",
    )
    parser.add_argument(
        "--no-scratch-build",
        dest="no_build",
        action="store_true",
        help="Do not run the koji scratch build",
    )
    parser.add_argument(
        "--debug", action="store_true", help="Outputs bunches of debugging info"
    )
    return parser


if __name__ == "__main__":
    try:
        ReviewRequest().main()
    except Exception as err:  # pylint: disable=broad-except
        print(err)


# vim: set expandtab ts=4 sw=4:
